<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Terminal</title><link>https://strajabot.com/</link><description>Recent content on Terminal</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 31 Jul 2024 18:52:31 +0200</lastBuildDate><atom:link href="https://strajabot.com/index.xml" rel="self" type="application/rss+xml"/><item><title>RISC-V: Fast Scalar strchrnul() in Assembly</title><link>https://strajabot.com/posts/fast-scalar-strchrnul-riscv/</link><pubDate>Wed, 31 Jul 2024 18:52:31 +0200</pubDate><guid>https://strajabot.com/posts/fast-scalar-strchrnul-riscv/</guid><description>What is strchrnul() ? char* strchrnul(const char* s, int c); is a FreeBSD libc string function that was first implemented as a GNU extension in glibc 2.1.1. This function is an extension of the strchr() function. The difference between the two functions can be found in the RETURN VALUES section of the manpage:
The functions strchr() and strrchr() return a pointer to the located character, or NULL if the character does not appear in the string.</description><content>&lt;h2 id="what-is-strchrnul-">What is strchrnul() ?&lt;/h2>
&lt;p>&lt;code>char* strchrnul(const char* s, int c);&lt;/code> is a &lt;a href="https://man.freebsd.org/cgi/man.cgi?strchr(3)">FreeBSD libc string function&lt;/a> that was first implemented as a GNU extension in glibc 2.1.1. This function is an extension of the &lt;code>strchr()&lt;/code> function. The difference between the two functions can be found in the &lt;a href="https://man.freebsd.org/cgi/man.cgi?strchr(3)#end">RETURN VALUES&lt;/a> section of the manpage:&lt;/p>
&lt;blockquote>
&lt;p>The functions &lt;code>strchr()&lt;/code> and &lt;code>strrchr()&lt;/code> return a pointer to the located character, or NULL if the character does not appear in the string.&lt;/p>
&lt;p>&lt;code>strchrnul()&lt;/code> returns a pointer to the terminating &lt;code>'\0'&lt;/code> if the character does not appear in the string.&lt;/p>
&lt;/blockquote>
&lt;p>This makes it really easy to use &lt;code>strchrnul()&lt;/code> to implement the regular &lt;code>strchr()&lt;/code> by checking the input character &lt;code>c&lt;/code> and the return value of &lt;code>strchrnul()&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">strchr&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> s, &lt;span style="color:#66d9ef">int&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">strchrnul&lt;/span>(s, c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">==&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>)c &lt;span style="color:#f92672">?&lt;/span> ptr : NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In fact, this is &lt;a href="https://github.com/freebsd/freebsd-src/blob/b7312c3df83df96662e83aaa0eaadda7ef66c8e3/lib/libc/string/strchr.c#L29-L34">how strchr() is implemented&lt;/a> in FreeBSD libc.&lt;/p>
&lt;p>Writing a fast &lt;code>strchrnul()&lt;/code> leads to a fast implemenation of &lt;code>strchr()&lt;/code>, without duplicating code. To completely understand how this implemntation works, I suggest reading the &lt;a href="http://localhost:1313/posts/fast-scalar-strlen-riscv/">strlen() article&lt;/a>.&lt;/p>
&lt;h2 id="spliting-the-work">Spliting the work&lt;/h2>
&lt;p>Similarly to what we did for the strlen() implementation, we want to do utilize the &lt;code>ld&lt;/code> instruction to load up to 8 characters at a time and check for &lt;code>c&lt;/code> and &lt;code>'\0'&lt;/code> using has_zero().
As was previously disscussed, a &lt;code>ld&lt;/code> instruction behaves consistently on all platforms only when the address of the load is aligned to an eightbyte (&lt;code>address % 8 == 0&lt;/code>).&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">/*
* a0 - const char* s
* a1 - int c;
*/
.globl strchrnul
.type strchrnul, @function
strchrnul:
/*
* a0 - const char* ptr;
* a1 - char cccccccc[8];
* a2 - char iter[8];
* a3 - char iter_end[8]
*/
/* ... */
&lt;/code>&lt;/pre>&lt;p>According to the RISC-V calling convention we accept the &lt;code>s&lt;/code> pointer thru the &lt;code>a0&lt;/code> register, and &lt;code>c&lt;/code> thru the &lt;code>a1&lt;/code> register. We will aditionally use the &lt;code>a2&lt;/code> calculations needed to find &lt;code>c&lt;/code>. We will also use the &lt;code>a3&lt;/code> register calculations needed for finding &lt;code>'\0'&lt;/code> (end of string).&lt;/p>
&lt;p>First thing we need to take care of is the type of &lt;code>c&lt;/code>. Because the C declaration of &lt;code>strchrnul&lt;/code> declares &lt;code>c&lt;/code> as an &lt;code>int&lt;/code> and not a &lt;code>char&lt;/code>, The calling code will pass a 32-bit value thru &lt;code>a1&lt;/code>. FreeBSD works with 8-bit characters, so we will first mask everything that doesn&amp;rsquo;t belong to the first byte.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm"> /* ... */
/* int -&amp;gt; char */
andi a1, a1, 0xFF
/* t0 = 0x0101010101010101 */
li t0, 0x01010101
slli t1, t0, 32
or t0, t0, t1
/* t1 = 0x8080808080808080 */
slli t1, t0, 7
/* spread char across bytes */
mul a1, a1, t0
/* ... */
&lt;/code>&lt;/pre>&lt;p>If we take a careful look at the declaration of &lt;code>strchrnul()&lt;/code> we will see that &lt;code>c&lt;/code> is declared as an &lt;code>int&lt;/code>.This will cause the C code that calls our function to pass a 32-bit (&lt;em>platform dependant&lt;/em>) value in &lt;code>a1&lt;/code>. Because of this we &amp;ldquo;cast&amp;rdquo; that value to a char which is a 8-bit (&lt;em>platform dependant&lt;/em>) value, trimming the rest of the bits.&lt;/p>
&lt;p>After this we load the &lt;code>0x0101010101010101&lt;/code> and &lt;code>0x8080808080808080&lt;/code> constants, which are going to be used for has_zero.&lt;/p>
&lt;p>The &lt;code>mul&lt;/code> instruction will clone &lt;code>c&lt;/code> eight times, filling the register.&lt;/p>
&lt;p>Now we need to handle the alignment of the start of the string.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm"> /* ... */
/* 1. align_offset */
andi t2, a0, 0b111
/* 2. align pointer */
andi a0, a0, ~0b111
/* 3. if pointer is aligned skip to loop */
beqz t2, .Lloop
/* 4. iter = *ptr */
ld a2, (a0)
/* 5. mask_start calculation */
slli t2, t2, 3
neg t2, t2
srl t2, t0, t2
/* 6. fill bytes before start with non-zero */
or a3, a2, t2
/* 7. find c setup */
xor a2, a2, a1
or a2, a2, t2
/* 8. has_zero for \0 */
not t3, a3
sub a3, a3, t0
and a3, a3, t3
and a3, a3, t1
/* 9. has_zero for c */
not t2, a2
sub a2, a2, t0
and a2, a2, t2
and a2, a2, t1
/* 10. if \0 or c was found, exit */
or a2, a2, a3
bnez a2, .Lfind_idx
/* 11. move to next eightbyte */
addi a0, a0, 8
.Lloop:
/* ... */
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>Calculate offset of &lt;code>s&lt;/code> from the previous aligned location.
&lt;ul>
&lt;li>&lt;code>align_offset = s % 8&lt;/code> &amp;lt;=&amp;gt; &lt;code>align_offset = s &amp;amp; 0b111&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Set pointer to previous aligned location.
&lt;ul>
&lt;li>&lt;code>ptr = s - (s % 8)&lt;/code> &amp;lt;=&amp;gt; &lt;code>ptr = s - (s &amp;amp; 0b111)&lt;/code> &amp;lt;=&amp;gt; &lt;code>ptr = s &amp;amp; ~0b111&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>In case that &lt;code>align_offset == 0&lt;/code>, &lt;code>ptr = s&lt;/code> is already aligned, and we can skip to the loop that doesn&amp;rsquo;t need to consider alignment.&lt;/li>
&lt;li>Now that &lt;code>ptr&lt;/code> is guaranteed to be aligned, we can load data from &lt;code>ptr&lt;/code> into &lt;code>iter&lt;/code>&lt;/li>
&lt;li>Because we aligned &lt;code>ptr&lt;/code> backwards before loading into &lt;code>iter&lt;/code>, it now contains a few bytes that don&amp;rsquo;t belong to the start of the string in the lower bytes of the register. To prevent &lt;code>has_zero&lt;/code> from finding &lt;code>c&lt;/code> or &lt;code>'\0'&lt;/code> in these bytes, we will mask them with a non-zero value. The mask is created by shifting the &lt;code>t0&lt;/code> register containing &lt;code>0x01...01&lt;/code> to the right by the appropriate number of bits. The calculaton is:
&lt;ul>
&lt;li>&lt;code>bits = align_offset * 8&lt;/code> &amp;lt;=&amp;gt; &lt;code>bits = align_offset &amp;lt;&amp;lt; 3&lt;/code> &amp;lt;=&amp;gt; &lt;code>slli t2, t2, 3&lt;/code>
&lt;ul>
&lt;li>Convert offset from number of bytes to number of bits.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>shift = 64 - bits&lt;/code> &amp;lt;=&amp;gt; &lt;code>shift = (-bits) &amp;amp; 0b111111&lt;/code> &amp;lt;=&amp;gt; &lt;code>neg t2, t2&lt;/code>
&lt;ul>
&lt;li>the &lt;code>srl&lt;/code> instruction &lt;a href="https://five-embeddev.com/riscv-user-isa-manual/Priv-v1.12/rv64.html#integer-computational-instructions">considers only the low 6 bits&lt;/a> of &lt;em>rs2&lt;/em> for the shift amount, removing the need for &lt;code>&amp;amp; 0b111111&lt;/code> in the assembly, resulting in a single &lt;code>neg&lt;/code> instruction.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>mask = 0x0101010101010101 &amp;gt;&amp;gt; shift&lt;/code> &amp;lt;=&amp;gt; &lt;code>srl t2, t0, t2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Write the masked value to &lt;code>iter_end&lt;/code>.&lt;/li>
&lt;li>We want to find the first &lt;code>c&lt;/code> in &lt;code>iter&lt;/code>. To do this we first &lt;code>iter = iter ^ cccccccc&lt;/code> which will cause all bytes that contain &lt;code>c&lt;/code> to become &lt;code>'\0'&lt;/code>. Afterwards we mask the bytes before the start of the string, to prevent finding &lt;code>c&lt;/code> before the start of the string.&lt;/li>
&lt;li>Use &lt;code>has_zero&lt;/code> to check for &lt;code>'\0'&lt;/code>.&lt;/li>
&lt;li>Use &lt;code>has_zero&lt;/code> to check for &lt;code>c&lt;/code>.&lt;/li>
&lt;li>If either of the &lt;code>has_zero&lt;/code> calculations returned a non-zero we want to find the first set bit, because it corresponds to the first appearance of &lt;code>'\0'&lt;/code> or &lt;code>c&lt;/code>. &lt;code>or&lt;/code> the two registers together and run &lt;code>find_idx&lt;/code> on that value.&lt;/li>
&lt;li>Neither &lt;code>'\0'&lt;/code> or &lt;code>c&lt;/code> was found, prepare for loop by moving &lt;code>ptr&lt;/code> to the next eightbyte&lt;/li>
&lt;/ol>
&lt;h2 id="removing-data-hazards">Removing data hazards&lt;/h2>
&lt;p>Generally, pipelined processors execute instructions faster when we avoid data hazards. One example of getting better performance by avoiding data hazards is the SiFive FU740:&lt;/p>
&lt;blockquote>
&lt;p>The pipeline implements a flexible dual-instruction-issue scheme. &lt;strong>Provided there are no data hazards&lt;/strong> between a pair of instructions, the &lt;strong>two instructions may issue in the same cycle&lt;/strong>, provided the following constraints are met: &amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>In case of the FU740 core, we can get up to double the performance out of the same code, if we reorder it to avoid data hazards. The two iterations of &lt;code>has_zero&lt;/code> we wrote above have data hazards between every instruction. This will lead to the core executing one instruction at a time. We can fix this by interleaving the two iterations of &lt;code>has_zero&lt;/code> together, resulting in the following code:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">
/* ... */
/* 1. align_offset */
andi t2, a0, 0b111
/* 2. align pointer */
andi a0, a0, ~0b111
/* 3. if pointer is aligned skip to loop */
beqz t2, .Lloop
/* 4. iter = *ptr */
ld a2, (a0)
/* 5. mask_start calculation */
slli t2, t2, 3
neg t2, t2
srl t2, t0, t2
/* 6. fill bytes before start with non-zero */
or a3, a2, t2
/* 7. find c setup */
xor a2, a2, a1
or a2, a2, t2
/* 8. and 9. has_zero for both \0 and c */
not t3, a3
not t2, a2
sub a3, a3, t0
sub a2, a2, t0
and a3, a3, t3
and a2, a2, t2
and a3, a3, t1
and a2, a2, t1
or a2, a2, a3
addi a0, a0, 8
bnez a2, .Lfind_idx
.Lloop:
/* ... */
&lt;/code>&lt;/pre>&lt;p>We also avoided the data hazard between the &lt;code>or a2, a2, a3&lt;/code> and &lt;code>bnez a2, .Lfind_idx&lt;/code> instruction, by moving the &lt;code>addi a0, a0, 8&lt;/code> in between them. We just need to remember to first &lt;code>addi a0, a0 -8&lt;/code> inside &lt;code>.Lfind_idx&lt;/code>. These data hazards will make a small difference here, because the code runs at most once per &lt;code>strchrnul()&lt;/code> call, but will make a lot of difference inside of &lt;code>.Lloop&lt;/code>.&lt;/p>
&lt;h2 id="the-loop">The loop&lt;/h2>
&lt;p>The loop is pretty much the same code as with the start, except we can remove all the extra computations for &lt;code>mask_start&lt;/code> leading to the following code:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm"> /* ... */
.Lloop:
ld a2, (a0)
/* has_zero for both \0 or c */
xor a3, a2, a1
not t2, a2
not t3, a3
sub a2, a2, t0
sub a3, a3, t0
and a2, a2, t2
and a3, a3, t3
and a2, a2, t1
and a3, a3, t1
/* if \0 or c was found, exit */
or a2, a2, a3
addi a0, a0, 8
beqz a2, .Lloop
.Lfind_idx:
/* ... */
&lt;/code>&lt;/pre>&lt;h2 id="finding-the-index-of-the-first-charachter">Finding the index of the first charachter&lt;/h2>
&lt;p>The code for finding the index of the first character (&lt;code>'\0'&lt;/code> or &lt;code>c&lt;/code>). We already solved this problem in &lt;code>strlen()&lt;/code>, so we are just going to adapt that code. First we need to add the &lt;code>addi a0, a0, -8&lt;/code> instruction to move &lt;code>ptr&lt;/code> back because it is pointing to the eightbyte for the next iteration, and not the one we terminated on. Also after finding the byte index inside of &lt;code>iter&lt;/code> we want to add that index to &lt;code>ptr&lt;/code> to find the resulting pointer and return that pointer thru &lt;code>a0&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm"> /* ... */
.Lfind_idx:
addi a0, a0, -8
/* isolate lowest set bit */
neg t0, a2
and a2, a2, t0
li t0, 0x0001020304050607
srli a2, a2, 7
/* lowest set bit is 2^(8*k)
* multiplying by it shifts the idx array in t0 by k bytes to the left */
mul a2, a2, t0
/* highest byte contains idx of first zero */
srli a2, a2, 56
add a0, a0, a2
ret
&lt;/code>&lt;/pre>&lt;p>Now that we understand the algorithm we can complete the implementation.&lt;/p>
&lt;h2 id="final-code">Final code&lt;/h2>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">/*
* a0 - const char* s
* a1 - int c;
*/
.globl strchrnul
.type strchrnul, @function
strchrnul:
/*
* a0 - const char* ptr;
* a1 - char cccccccc[8];
* a2 - char iter[8];
* a3 - char iter_end[8]
*/
/* int -&amp;gt; char */
andi a1, a1, 0xFF
/* t0 = 0x0101010101010101 */
li t0, 0x01010101
slli t1, t0, 32
or t0, t0, t1
/* t1 = 0x8080808080808080 */
slli t1, t0, 7
/* spread char across bytes */
mul a1, a1, t0
/* align_offset */
andi t2, a0, 0b111
/* align pointer */
andi a0, a0, ~0b111
/* if pointer is aligned skip to loop */
beqz t2, .Lloop
/* iter = *ptr */
ld a2, (a0)
/* mask_start calculation */
slli t2, t2, 3
neg t2, t2
srl t2, t0, t2
/* fill bytes before start with non-zero */
or a3, a2, t2
/* find c setup */
xor a2, a2, a1
or a2, a2, t2
/* has_zero for both \0 and c */
not t3, a3
not t2, a2
sub a3, a3, t0
sub a2, a2, t0
and a3, a3, t3
and a2, a2, t2
and a3, a3, t1
and a2, a2, t1
or a2, a2, a3
addi a0, a0, 8
bnez a2, .Lfind_idx
.Lloop:
ld a2, (a0)
/* has_zero for both \0 or c */
xor a3, a2, a1
not t2, a2
not t3, a3
sub a2, a2, t0
sub a3, a3, t0
and a2, a2, t2
and a3, a3, t3
and a2, a2, t1
and a3, a3, t1
/* if \0 or c was found, exit */
or a2, a2, a3
addi a0, a0, 8
beqz a2, .Lloop
.Lfind_idx:
addi a0, a0, -8
/* isolate lowest set bit */
neg t0, a2
and a2, a2, t0
li t0, 0x0001020304050607
srli a2, a2, 7
/* lowest set bit is 2^(8*k)
* multiplying by it shifts the idx array in t0 by k bytes to the left */
mul a2, a2, t0
/* highest byte contains idx of first zero */
srli a2, a2, 56
add a0, a0, a2
ret
&lt;/code>&lt;/pre>&lt;h2 id="performance-metrics">Performance metrics&lt;/h2>
&lt;p>Performance was measured on a SiFive Unmatched development board using strperf.&lt;/p>
&lt;ul>
&lt;li>The FreeBSD C &lt;a href="https://github.com/freebsd/freebsd-src/blob/main/lib/libc/string/strchrnul.c">base implementation&lt;/a> is the multiplatfrom implementation. It’s used for the kernel, and when a machine dependent implementation doesn’t exist.&lt;/li>
&lt;li>RISC-V &lt;a href="https://github.com/strajabot/freebsd-src/blob/0e2a27ba92832bd52790dcc255a68a0741119667/lib/libc/riscv/string/strchrnul.S">optimized implementation&lt;/a> is the one from this article.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>| In B/s | FreeBSD base impl | RISC-V optimized impl |
|---------|---------------------|--------------------------------------|
| Short | 183.8Mi ± 5% | 287.2Mi ± 0% +56.27% (p=0.000 n=20) |
| Mid | 397.3Mi ± 3% | 564.6Mi ± 0% +42.12% (p=0.000 n=20) |
| Long | 820.5Mi ± 0% | 902.5Mi ± 0% +9.99% (p=0.000 n=20) |
| geomean | 391.3Mi | 527.0Mi +34.68% |
&lt;/code>&lt;/pre>&lt;h2 id="further-reading">Further reading&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://graphics.stanford.edu/~seander/bithacks.html">Sean Eron Anderson - Bit Twiddling Hacks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685">Henry Warren- Hacker&amp;rsquo;s Delight&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V User ISA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://five-embeddev.com/quickref/instructions.html#-rv64">RISC-V Instruction Quick Reference&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>RISC-V: Fast Scalar strlen() in Assembly</title><link>https://strajabot.com/posts/fast-scalar-strlen-riscv/</link><pubDate>Fri, 21 Jun 2024 18:08:40 +0200</pubDate><guid>https://strajabot.com/posts/fast-scalar-strlen-riscv/</guid><description>Introduction This is the first part of the series of articles I will be doing during my Google Summer of Code Project. This project constitutes of writing optimized assembly routines for FreeBSD&amp;rsquo;s libc string functions in RISC-V assembly.
Hardware Limitations String functions are commonly used to demonstrate SIMD techinques. Most of the time, these examples use SIMD instructions to achieve a performance improvement. This would be the case for my project too, if it weren&amp;rsquo;t for one problem: Hardware support for the V (Vector operations) extension.</description><content>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This is the first part of the series of articles I will be doing during my &lt;a href="https://wiki.freebsd.org/SummerOfCode2024Projects/PortAmd64SIMDLibcOptimizationsToRiscv64">Google Summer of Code Project&lt;/a>. This project constitutes of writing optimized assembly routines for FreeBSD&amp;rsquo;s libc string functions in RISC-V assembly.&lt;/p>
&lt;h2 id="hardware-limitations">Hardware Limitations&lt;/h2>
&lt;p>String functions are commonly used to demonstrate SIMD techinques. Most of the time, these examples use SIMD instructions to achieve a performance improvement. This would be the case for my project too, if it weren&amp;rsquo;t for one problem: Hardware support for the V (Vector operations) extension. Because of this limitation, a decision was made not to use the V extension for the optimizations, so that the improvments can be noticed on a broader spectrum of hardware. The decision was also made to have multiple implementations based on which extensions are supported by the core. This post will only consider instructions that are a part of RV64G (IMA, Zicsr, Zifencei).&lt;/p>
&lt;h2 id="swar">SWAR&lt;/h2>
&lt;p>To mitigate the lack of SIMD instructions we will be using SWAR (SIMD Within A Register) techinques to process more data at a time inside of general purpose registers.&lt;/p>
&lt;h2 id="trivial-strlen">Trivial strlen()&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">size_t&lt;/span> &lt;span style="color:#a6e22e">strlen&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (s &lt;span style="color:#f92672">=&lt;/span> str; &lt;span style="color:#f92672">*&lt;/span>s; &lt;span style="color:#f92672">++&lt;/span>s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (s &lt;span style="color:#f92672">-&lt;/span> str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And, when compiled, this code emits roughly the following assembly&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">strlen:
lbu a5,0(a0)
beq a5,zero,.L4
mv a5,a0
.L3:
lbu a4,1(a5)
addi a5,a5,1
bne a4,zero,.L3
sub a0,a5,a0
ret
.L4:
li a0,0
ret
&lt;/code>&lt;/pre>&lt;p>The example code loads 1 byte (one character) into &lt;code>a5&lt;/code> using the &lt;code>lbu&lt;/code> (load byte unsigend) instruction. We can increase performance by using the The RISC-V &lt;code>ld&lt;/code> (load double word) instruction which can load 8 bytes (eight characters) at at time into a register. However we need to take one thing into consideration:&lt;/p>
&lt;h2 id="memory-access-alignment">Memory access alignment&lt;/h2>
&lt;p>We say that a memory access operation is naturally aligned when the address of the data being accessed is an integer multiple of the size of data being accessed.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;ul>
&lt;li>&lt;code>lb&lt;/code> access is always naturally aligned, because &lt;code>address % 1 == 0&lt;/code>&lt;/li>
&lt;li>&lt;code>lw&lt;/code> access for address &lt;code>0x1004&lt;/code> is naturally aligned, because the size of data being accessed is 4 bytes and &lt;code>0x1004 % 4 == 0&lt;/code>&lt;/li>
&lt;li>&lt;code>ld&lt;/code> access for address &lt;code>0x1004&lt;/code> isn’t naturally aligned, because the size of data being accessed is 8 bytes and &lt;code>0x1004 % 8 != 0&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Naturally aligned loads and stores are guaranteed to not raise a address-missaligned exception.&lt;/p>
&lt;p>Depending on the execution environment, missaligned loads and stores may be implemented in hardware, or emulated in software using an exception handler, or cause a fatal exception. (&lt;a href="https://five-embeddev.com/riscv-user-isa-manual/latest-latex/rv32.html#sec:rv32:ldst">More precise info&lt;/a>). Because they might be emulated in software, missaligned accesses may lead to orders of magnitude worse performance then aligned ones.&lt;/p>
&lt;p>For the reasons above, we want all loads and stores in our code to be naturally aligned. Because &lt;code>void* str&lt;/code> may not be eightbyte aligned, when loading the first eightbyte we first want to align the address. This can easily be done by &lt;code>str_ptr = str &amp;amp; ~0b111&lt;/code>. In case that &lt;code>str_ptr != str&lt;/code> the first load is going to load &lt;code>str - str_ptr&lt;/code> extra bytes that are before the start of the string. We fill these extra bytes with &lt;code>0xFF&lt;/code> to avoid handling the case where they contained a zerobyte. All the following loads are guaranteed to be aligned because the load address will be &lt;code>str_ptr + 8*i&lt;/code>.&lt;/p>
&lt;p>Now we can start implementing this in assembly:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">/*
* register a0 - void* str
*/
.globl strlen
.type strlen, @function
strlen:
/*
* register a0 - char* str_start
* register a1 - char* str_ptr
* register a2 - char[8] iter
*/
/* check alignment of str_start */
andi a1, a0, ~0b111
ld a2, (a1)
beq a1, a0, .Lhas_zero
/*
* fill bytes before str_start with 0xFF
* to avoid finding zero before str_start
*/
slli t2, a0, 3
li t3, -1 # load 0xFFFFFFFFFFFFFFFF
sll t3, t3, t2 # shift mask by unaligned bytes
not t3, t3 # mask bytes before str_start
or a2, a2, t3 # fill with 0xFF
/*
* iteration of has_zero
*/
.Lloop_has_zero:
ld a2, 8(a1)
addi a1, a1, 8 # move str_ptr to next eightbyte
.Lhas_zero:
/*
* check if a2 contains a zerobyte
* if no zerobyte found, continue loop
*/
.Lfind_zero:
/*
* Find the byte index of first zerobyte in a2
*/
ret
&lt;/code>&lt;/pre>&lt;p>Now that we have loaded 8 consecutive characters into a register we need to search them for a zero byte. For reasons that will become clear later, we will split this process into two steps:&lt;/p>
&lt;ul>
&lt;li>Determining if the register contains a zero byte&lt;/li>
&lt;li>Finding the index of the zero byte&lt;/li>
&lt;/ul>
&lt;h2 id="determining-if-the-register-contains-a-zero-byte">Determining if the register contains a zero byte&lt;/h2>
&lt;p>There is one obvious approach to checking if the register contains a zero byte:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">has_zero&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>((value &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFF&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x00&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However we can do much better than this, in fact we can even avoid the for loop and if entirely using the following technique:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">uint64_t&lt;/span> &lt;span style="color:#a6e22e">has_zero&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (value &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x0101010101010101ull&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">~&lt;/span>value &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x8080808080808080ull&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For every byte equal to zero, this function will return the highest bit of that byte equal to 1.
This approach works beacuse of the following:&lt;/p>
&lt;ol>
&lt;li>The expression &lt;code>value - 0x0101010101010101ull&lt;/code> will set the highest bit for every byte that is either &lt;code>0x00&lt;/code> or greater than &lt;code>0x80&lt;/code>&lt;/li>
&lt;li>The expression &lt;code>~value &amp;amp; 0x8080808080808080ull&lt;/code> will set the highest bit for every byte whose highest bit was &lt;code>0&lt;/code>&lt;/li>
&lt;li>By and-ing (1) and (2) the return value will have the highest bit of each byte set only when that byte is equal to &lt;code>0x00&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>We can check if the eightbyte contains a zero by passing it to &lt;code>has_zero&lt;/code> and checking if the return value is non-zero. This can be implemented in assembly like so:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">/*
* register a0 - void* str
*/
.globl strlen
.type strlen, @function
strlen:
/*
* register a0 - char* str_start
* register a1 - char* str_ptr
* register a2 - char[8] iter
*/
/* load constants for has_zero */
li t0, 0x0101010101010101
slli t1, t0, 7 # 0x8080808080808080, avoid li
/* check alignment of str_start */
andi a1, a0, ~0b111
ld a2, (a1)
beq a1, a0, .Lhas_zero
/*
* fill bytes before str_start with 0xFF
* to avoid finding zero before str_start
*/
slli t2, a0, 3
li t3, -1 # load 0xFFFFFFFFFFFFFFFF
sll t3, t3, t2 # shift mask by unaligned bytes
not t3, t3 # mask bytes before str_start
or a2, a2, t3 # fill with 0xFF
/* iteration of has_zero */
not t2, a2
sub a2, a2, t0
and a2, a2, t2
and a2, a2, t1
bnez a2, .Lfind_zero
.Lloop_has_zero:
ld a2, 8(a1)
addi a1, a1, 8 # move str_ptr to next eightbyte
.Lhas_zero:
not t2, a2
sub a2, a2, t0
and a2, a2, t2
and a2, a2, t1
beqz a2, .Lloop_has_zero
.Lfind_zero:
/*
* Find the byte index of first zerobyte in a2
*/
ret
&lt;/code>&lt;/pre>&lt;h2 id="finding-the-index-of-the-zero-byte">Finding the index of the zero byte&lt;/h2>
&lt;p>Now that we have figured out how to check if the eightbyte contains a zero, we need to get the index of that zero byte because that&amp;rsquo;s the end of the string.&lt;/p>
&lt;p>The best solution would be to use a instruction that does a &lt;a href="https://en.wikipedia.org/wiki/Find_first_set">bitscan forward&lt;/a> so that we can get the index on the first 1 bit and convert that into a byte index. However RV64G doesn&amp;rsquo;t contain such bit manipulation instructions (The B extension does). This means we need to implement this in software.&lt;/p>
&lt;p>First we are going to isolate the least significant 1 bit (LS1B). The standard way to isolate it is &lt;code>ls1b = value &amp;amp; -value&lt;/code>. After doing this, our register will be left with only one bit set, and that is the highest bit of the first zerobyte. Now we need to map all of the possibilities into the correct byte indexes.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>VALUE&lt;/th>
&lt;th>BYTE INDEX&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x00000000000000&lt;strong>8&lt;/strong>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x000000000000&lt;strong>8&lt;/strong>000&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x0000000000&lt;strong>8&lt;/strong>00000&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x00000000&lt;strong>8&lt;/strong>0000000&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x000000&lt;strong>8&lt;/strong>000000000&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x0000&lt;strong>8&lt;/strong>00000000000&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x00&lt;strong>8&lt;/strong>0000000000000&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x&lt;strong>8&lt;/strong>000000000000000&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>There are only 8 posibliites for the values that we need to map into 8 byte indicies. We can make use of the mathematical property of base 2 numbers: &lt;code>number * 2^exp = number &amp;lt;&amp;lt; exp&lt;/code> to calculate the byte index.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">uint64_t&lt;/span> &lt;span style="color:#a6e22e">find_zero&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">&amp;amp;=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">=&lt;/span> value &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x0001020304050607ull&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> value &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Explanation of the code line by line.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Line&lt;/th>
&lt;th>Explanation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>value &amp;amp;= -value;&lt;/td>
&lt;td>Isolate the LS1B to only consider the first zero.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>value &amp;raquo;= 7;&lt;/td>
&lt;td>Shift LS1B from &lt;code>8 * byte_idx + 7&lt;/code> to &lt;code>8 * byte_idx&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>value = value * 0x0001020304050607ull;&lt;/td>
&lt;td>Multiply with constant to get the byte index in the highest byte utilising the property above.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>return value &amp;raquo; 56;&lt;/td>
&lt;td>Return the highest byte.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Now that we understand the algorithm we can complete the implementation.&lt;/p>
&lt;h2 id="final-code">Final code&lt;/h2>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">/*
* register a0 - void* str
*/
.globl strlen
.type strlen, @function
strlen:
/*
* register a0 - char* str_start
* register a1 - char* str_ptr
* register a2 - char[8] iter
*/
/* load constants for has_zero */
li t0, 0x0101010101010101
slli t1, t0, 7 # 0x8080808080808080, avoid li
/* check alignment of str_start */
andi a1, a0, ~0b111
ld a2, (a1)
beq a1, a0, .Lhas_zero
/*
* fill bytes before str_start with 0xFF
* to avoid finding zero before str_start
*/
slli t2, a0, 3
li t3, -1 # load 0xFFFFFFFFFFFFFFFF
sll t3, t3, t2 # shift mask by unaligned bytes
not t3, t3 # mask bytes before str_start
or a2, a2, t3 # fill with 0xFF
/* iteration of has_zero */
not t2, a2
sub a2, a2, t0
and a2, a2, t2
and a2, a2, t1
bnez a2, .Lfind_zero
.Lloop_has_zero:
ld a2, 8(a1)
addi a1, a1, 8 # move str_ptr to next eightbyte
.Lhas_zero:
not t2, a2
sub a2, a2, t0
and a2, a2, t2
and a2, a2, t1
beqz a2, .Lloop_has_zero
.Lfind_zero:
neg a3, a2 #a3 = -iter
and t1, a2, a3 #t1 = (iter &amp;amp; -iter)
li t0, 0x0001020304050607
srli t1, t1, 7
mul t1, t1, t0
srli t1, t1, 56
add a1, a1, t1
sub a0, a1, a0
ret
&lt;/code>&lt;/pre>&lt;h2 id="performance-metrics">Performance metrics&lt;/h2>
&lt;p>Performance was measured on a SiFive Unmatched development board using &lt;a href="https://github.com/clausecker/strperf">strperf&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>The Trivial implementation was the code from the start of the article compiled using &lt;code>clang&lt;/code> with &lt;code>-O2&lt;/code>&lt;/li>
&lt;li>The FreeBSD C base implementation is the &lt;a href="https://github.com/freebsd/freebsd-src/blob/main/lib/libc/string/strlen.c">multiplatfrom implementation&lt;/a>. It&amp;rsquo;s used for the kernel, and when a machine dependent implementation doesn&amp;rsquo;t exist.&lt;/li>
&lt;li>RISC-V optimized implementation is the one from this article.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>| In B/s | Trivial impl | FreeBSD base impl | RISC-V optimized impl |
|---------|---------------------------------|-------------------------------------------|----------------------------------------|
| Short | 216.5Mi ± 0% | 220.3Mi ± 14% ~ (p=0.446 n=20+21) | 296.8Mi ± 0% +37.12% (p=0.000 n=20) |
| Mid | 284.8Mi ± 0% | 477.6Mi ± 3% +67.67% (p=0.000 n=20+21) | 621.3Mi ± 0% +118.11% (p=0.000 n=20) |
| Long | 318.6Mi ± 1% | 956.9Mi ± 0% +200.38% (p=0.000 n=20+21) | 1076.7Mi ± 0% +237.99% (p=0.000 n=20) |
| geomean | 269.8Mi | 465.2Mi +72.42% | 583.4Mi +116.22% |
&lt;/code>&lt;/pre>&lt;h2 id="further-optimizations">Further optimizations&lt;/h2>
&lt;p>For further optimization, the main loop can be unrolled. Also in the current implementation there are a couple of instructions to be saved for anyone that can find them ;)&lt;/p>
&lt;h2 id="further-reading">Further reading&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://summerofcode.withgoogle.com/">Google Summer of Code&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V User ISA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://five-embeddev.com/quickref/instructions.html#-rv64">RISC-V Instruction Quick Reference&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mcyoung.xyz/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>RISC-V: Managing concurrency using spinlocks</title><link>https://strajabot.com/posts/kernel-concurrency-riscv/</link><pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate><guid>https://strajabot.com/posts/kernel-concurrency-riscv/</guid><description>Why do we need synchronization? When coding a multicore operating system, to minimize overhead associated with executing system calls, we want to be able to run kernel code on multiple cores at the same time. To do this correctly, we need to solve the critical section problem, a problem that arises frequently when implementing a multiprocessor, preemptive kernel.
To illustrate the critical section problem, we will take a close look at a memory allocator for fixed size blocks.</description><content>&lt;h2 id="why-do-we-need-synchronization">Why do we need synchronization?&lt;/h2>
&lt;p>When coding a multicore operating system, to minimize overhead associated with executing system calls, we want to be able to run kernel code on multiple cores at the same time. To do this correctly, we need to solve the critical section problem, a problem that arises frequently when implementing a multiprocessor, preemptive kernel.&lt;/p>
&lt;p>To illustrate the critical section problem, we will take a close look at a memory allocator for fixed size blocks. This allocator will function by keeping track of free blocks by keeping them inside a linked list.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> free_block {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> free_block&lt;span style="color:#f92672">*&lt;/span> next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> free_block&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">alloc_block&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> block &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>) head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> block;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When we think about it, the compiled version of the code above could look like:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">alloc_block:
ld a0, head #a0 &amp;lt;- head
ld a1, 0(a0) #a1 &amp;lt;- head-&amp;gt;next
sd a1, head #head &amp;lt;- a1
ret #return value is in a0
&lt;/code>&lt;/pre>&lt;p>Since &lt;code>alloc_block&lt;/code> can be executing on multiple processor cores and we haven&amp;rsquo;t implemented any synchronization, the following situation can occur:&lt;/p>
&lt;pre tabindex="0">&lt;code>// INITIAL VALUES
head = 0x1000;
head-&amp;gt;next = 0x2000;
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>TIME&lt;/th>
&lt;th>THREAD 1 (ON CORE 1)&lt;/th>
&lt;th>THREAD 2 (ON CORE 2)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1.&lt;/td>
&lt;td>ld a0, head [head=0x1000]&lt;/td>
&lt;td>?&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2.&lt;/td>
&lt;td>ld a1, 0(a0) [head-&amp;gt;next=0x2000]&lt;/td>
&lt;td>ld a0, head [head=0x1000]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3.&lt;/td>
&lt;td>/&lt;/td>
&lt;td>ld a1, 0(a0) [head-&amp;gt;next=0x2000]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4.&lt;/td>
&lt;td>sd a1, head [head=0x2000]&lt;/td>
&lt;td>/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5.&lt;/td>
&lt;td>ret [return a0=0x1000]&lt;/td>
&lt;td>sd a1, head [head=0x2000]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6.&lt;/td>
&lt;td>?&lt;/td>
&lt;td>ret [return a0=0x1000]&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>If we look closely at the return value, we realize that both threads have allocated the same block, which is not correct behavior because now both threads are sharing a block that they believe to have exclusive access to. Mistakes like this inside the kernel can cause catastrophic failures of user code and the operating system, depending on what the allocated memory is used for.&lt;/p>
&lt;p>The issue in this code arises from the fact that changing the head of the list is not an atomic operation, leading to THREAD 2 being able to read the old head value before THREAD 1 gets to update it by storing the new value.&lt;/p>
&lt;p>To find a solution to this problem, we will think about the correct behavior. The correct behavior is that once either of the threads starts the operation by executing &lt;code>void* block = (void*) head;&lt;/code> no other threads can start executing the operation until the thread that started the operation finishes executing &lt;code>head = head-&amp;gt;next;&lt;/code>. This way it is impossible for threads to read the old value of &lt;code>head&lt;/code>.&lt;/p>
&lt;p>So, for the code to behave correctly, it needs to &lt;em>lock&lt;/em> the &lt;em>section&lt;/em> before starting the operation, and it needs to &lt;em>unlock&lt;/em> the &lt;em>section&lt;/em> when it finishes the operation so that other threads can start their operations.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> free_block {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> free_block&lt;span style="color:#f92672">*&lt;/span> next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> section;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> free_block&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">alloc_block&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> block &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>) head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> block;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We now need to implement &lt;code>lock&lt;/code> and &lt;code>unlock&lt;/code> .&lt;/p>
&lt;h2 id="void-lockint-section">&lt;code>void lock(int* section);&lt;/code>&lt;/h2>
&lt;div class="goat svg-container ">
&lt;svg
xmlns="http://www.w3.org/2000/svg"
font-family="Menlo,Lucida Console,monospace"
viewBox="0 0 472 329"
>
&lt;g transform='translate(8,16)'>
&lt;path d='M 16,0 L 112,0' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,32 L 64,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 72,48 L 176,48' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 216,48 L 240,48' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,96 L 176,96' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 240,128 L 264,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,176 L 120,176' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,208 L 120,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 216,224 L 240,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,272 L 120,272' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,304 L 120,304' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 20,72 L 64,72' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,72 L 108,72' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 20,120 L 108,120' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,176 L 8,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,272 L 8,304' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,0 L 16,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 64,64' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,128 L 64,160' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,224 L 64,256' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 112,0 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,176 L 120,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,272 L 120,304' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 176,48 L 176,96' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 240,48 L 240,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 240,128 L 240,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,96 L 20,72' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 108,120 L 120,96' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,96 L 20,120' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 108,72 L 120,96' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,120 L 64,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,216 L 64,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='72.000000,64.000000 60.000000,58.400002 60.000000,69.599998' fill='currentColor' transform='rotate(90.000000, 64.000000, 64.000000)'>&lt;/polygon>
&lt;path d='M 64,160 L 64,168' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,160.000000 68.000000,154.399994 68.000000,165.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 160.000000)'>&lt;/polygon>
&lt;path d='M 64,256 L 64,264' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,256.000000 68.000000,250.399994 68.000000,261.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 256.000000)'>&lt;/polygon>
&lt;polygon points='80.000000,48.000000 68.000000,42.400002 68.000000,53.599998' fill='currentColor' transform='rotate(180.000000, 72.000000, 48.000000)'>&lt;/polygon>
&lt;polygon points='272.000000,128.000000 260.000000,122.400002 260.000000,133.600006' fill='currentColor' transform='rotate(0.000000, 264.000000, 128.000000)'>&lt;/polygon>
&lt;text text-anchor='middle' x='0' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='100' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='24' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='196' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='24' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='100' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='32' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='196' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='32' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='100' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='40' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='196' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='40' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='20' fill='currentColor' style='font-size:1em'>L&lt;/text>
&lt;text text-anchor='middle' x='48' y='100' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='48' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='196' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='48' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='20' fill='currentColor' style='font-size:1em'>O&lt;/text>
&lt;text text-anchor='middle' x='56' y='100' fill='currentColor' style='font-size:1em'>i&lt;/text>
&lt;text text-anchor='middle' x='56' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='196' fill='currentColor' style='font-size:1em'>i&lt;/text>
&lt;text text-anchor='middle' x='56' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='292' fill='currentColor' style='font-size:1em'>R&lt;/text>
&lt;text text-anchor='middle' x='64' y='20' fill='currentColor' style='font-size:1em'>C&lt;/text>
&lt;text text-anchor='middle' x='64' y='100' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='64' y='196' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='64' y='292' fill='currentColor' style='font-size:1em'>E&lt;/text>
&lt;text text-anchor='middle' x='72' y='20' fill='currentColor' style='font-size:1em'>K&lt;/text>
&lt;text text-anchor='middle' x='72' y='100' fill='currentColor' style='font-size:1em'>n&lt;/text>
&lt;text text-anchor='middle' x='72' y='196' fill='currentColor' style='font-size:1em'>n&lt;/text>
&lt;text text-anchor='middle' x='72' y='292' fill='currentColor' style='font-size:1em'>T&lt;/text>
&lt;text text-anchor='middle' x='80' y='148' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='80' y='244' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='88' y='100' fill='currentColor' style='font-size:1em'>=&lt;/text>
&lt;text text-anchor='middle' x='88' y='148' fill='currentColor' style='font-size:1em'>r&lt;/text>
&lt;text text-anchor='middle' x='88' y='196' fill='currentColor' style='font-size:1em'>=&lt;/text>
&lt;text text-anchor='middle' x='88' y='244' fill='currentColor' style='font-size:1em'>r&lt;/text>
&lt;text text-anchor='middle' x='96' y='148' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='96' y='244' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='104' y='100' fill='currentColor' style='font-size:1em'>0&lt;/text>
&lt;text text-anchor='middle' x='104' y='148' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='104' y='196' fill='currentColor' style='font-size:1em'>1&lt;/text>
&lt;text text-anchor='middle' x='104' y='244' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='128' y='84' fill='currentColor' style='font-size:1em'>f&lt;/text>
&lt;text text-anchor='middle' x='136' y='84' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='144' y='84' fill='currentColor' style='font-size:1em'>l&lt;/text>
&lt;text text-anchor='middle' x='152' y='84' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='160' y='84' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='280' y='132' fill='currentColor' style='font-size:1em'>M&lt;/text>
&lt;text text-anchor='middle' x='288' y='132' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='296' y='132' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='304' y='132' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='320' y='132' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='328' y='132' fill='currentColor' style='font-size:1em'>x&lt;/text>
&lt;text text-anchor='middle' x='336' y='132' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='344' y='132' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='352' y='132' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='360' y='132' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='368' y='132' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='384' y='132' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='392' y='132' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='400' y='132' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='408' y='132' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='416' y='132' fill='currentColor' style='font-size:1em'>i&lt;/text>
&lt;text text-anchor='middle' x='424' y='132' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='432' y='132' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='440' y='132' fill='currentColor' style='font-size:1em'>l&lt;/text>
&lt;text text-anchor='middle' x='448' y='132' fill='currentColor' style='font-size:1em'>l&lt;/text>
&lt;text text-anchor='middle' x='456' y='132' fill='currentColor' style='font-size:1em'>y&lt;/text>
&lt;/g>
&lt;/svg>
&lt;/div>
&lt;h2 id="void-unlockint-section">&lt;code>void unlock(int* section);&lt;/code>&lt;/h2>
&lt;div class="goat svg-container ">
&lt;svg
xmlns="http://www.w3.org/2000/svg"
font-family="Menlo,Lucida Console,monospace"
viewBox="0 0 480 249"
>
&lt;g transform='translate(8,16)'>
&lt;path d='M 16,0 L 112,0' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,32 L 64,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,96 L 120,96' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,128 L 120,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,192 L 120,192' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,224 L 120,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,96 L 8,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,192 L 8,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,0 L 16,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 64,80' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,144 L 64,176' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 112,0 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,96 L 120,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,192 L 120,224' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,136 L 64,144' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,80 L 64,88' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,80.000000 68.000000,74.400002 68.000000,85.599998' fill='currentColor' transform='rotate(90.000000, 64.000000, 80.000000)'>&lt;/polygon>
&lt;path d='M 64,176 L 64,184' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,176.000000 68.000000,170.399994 68.000000,181.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 176.000000)'>&lt;/polygon>
&lt;text text-anchor='middle' x='0' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='116' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='24' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='116' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='32' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='20' fill='currentColor' style='font-size:1em'>U&lt;/text>
&lt;text text-anchor='middle' x='40' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='116' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='40' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='20' fill='currentColor' style='font-size:1em'>N&lt;/text>
&lt;text text-anchor='middle' x='48' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='116' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='48' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='20' fill='currentColor' style='font-size:1em'>L&lt;/text>
&lt;text text-anchor='middle' x='56' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='116' fill='currentColor' style='font-size:1em'>i&lt;/text>
&lt;text text-anchor='middle' x='56' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='212' fill='currentColor' style='font-size:1em'>R&lt;/text>
&lt;text text-anchor='middle' x='64' y='20' fill='currentColor' style='font-size:1em'>O&lt;/text>
&lt;text text-anchor='middle' x='64' y='116' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='64' y='212' fill='currentColor' style='font-size:1em'>E&lt;/text>
&lt;text text-anchor='middle' x='72' y='20' fill='currentColor' style='font-size:1em'>C&lt;/text>
&lt;text text-anchor='middle' x='72' y='116' fill='currentColor' style='font-size:1em'>n&lt;/text>
&lt;text text-anchor='middle' x='72' y='212' fill='currentColor' style='font-size:1em'>T&lt;/text>
&lt;text text-anchor='middle' x='80' y='20' fill='currentColor' style='font-size:1em'>K&lt;/text>
&lt;text text-anchor='middle' x='80' y='68' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='88' y='68' fill='currentColor' style='font-size:1em'>r&lt;/text>
&lt;text text-anchor='middle' x='88' y='116' fill='currentColor' style='font-size:1em'>=&lt;/text>
&lt;text text-anchor='middle' x='96' y='68' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='104' y='68' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='104' y='116' fill='currentColor' style='font-size:1em'>0&lt;/text>
&lt;/g>
&lt;/svg>
&lt;/div>
&lt;p>However for implementing &lt;code>lock&lt;/code> we must avoid any implementations that compile to LOAD -&amp;gt; BRANCH -&amp;gt; STORE because writing the &lt;code>lock&lt;/code> function like that will make it susceptible to the same problem we had in &lt;code>alloc_block&lt;/code>. To implement this behavior correctly we turn to atomic instructions.&lt;/p>
&lt;h2 id="amoswap-rd-rs2-rs1">&lt;code>amoswap rd, rs2, (rs1)&lt;/code>&lt;/h2>
&lt;p>&lt;code>amoswap&lt;/code> is an instruction from the A extension which allows us to swap the data from &lt;code>rs2 =&amp;gt; (rs1) =&amp;gt; rd&lt;/code> as a single atomic operation. Using this instruction we can implement &lt;code>lock&lt;/code> like so:&lt;/p>
&lt;div class="goat svg-container ">
&lt;svg
xmlns="http://www.w3.org/2000/svg"
font-family="Menlo,Lucida Console,monospace"
viewBox="0 0 360 409"
>
&lt;g transform='translate(8,16)'>
&lt;path d='M 16,0 L 112,0' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,32 L 64,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,80 L 112,80' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,112 L 112,112' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 72,144 L 296,144' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,176 L 256,176' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,208 L 64,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,208 L 256,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,272 L 296,272' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,352 L 120,352' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,384 L 120,384' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 20,248 L 64,248' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,248 L 108,248' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 20,296 L 108,296' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,352 L 8,384' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,0 L 16,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,80 L 16,112' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 16,176 L 16,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,32 L 64,64' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,128 L 64,160' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,208 L 64,240' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,304 L 64,336' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 112,0 L 112,32' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 112,80 L 112,112' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 120,352 L 120,384' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 256,176 L 256,208' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 296,144 L 296,272' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,272 L 20,248' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 108,296 L 120,272' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 8,272 L 20,296' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 108,248 L 120,272' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,120 L 64,128' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,296 L 64,304' fill='none' stroke='currentColor'>&lt;/path>
&lt;path d='M 64,64 L 64,72' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,64.000000 68.000000,58.400002 68.000000,69.599998' fill='currentColor' transform='rotate(90.000000, 64.000000, 64.000000)'>&lt;/polygon>
&lt;path d='M 64,160 L 64,168' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,160.000000 68.000000,154.399994 68.000000,165.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 160.000000)'>&lt;/polygon>
&lt;polygon points='72.000000,240.000000 60.000000,234.399994 60.000000,245.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 240.000000)'>&lt;/polygon>
&lt;path d='M 64,336 L 64,344' fill='none' stroke='currentColor'>&lt;/path>
&lt;polygon points='80.000000,336.000000 68.000000,330.399994 68.000000,341.600006' fill='currentColor' transform='rotate(90.000000, 64.000000, 336.000000)'>&lt;/polygon>
&lt;polygon points='80.000000,144.000000 68.000000,138.399994 68.000000,149.600006' fill='currentColor' transform='rotate(180.000000, 72.000000, 144.000000)'>&lt;/polygon>
&lt;text text-anchor='middle' x='0' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='0' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='244' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='8' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='16' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='24' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='100' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='32' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='196' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='32' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='32' y='276' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='32' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='100' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='40' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='196' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='40' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='40' y='276' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='40' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='20' fill='currentColor' style='font-size:1em'>L&lt;/text>
&lt;text text-anchor='middle' x='48' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='100' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='48' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='196' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='48' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='48' y='276' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='48' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='20' fill='currentColor' style='font-size:1em'>O&lt;/text>
&lt;text text-anchor='middle' x='56' y='68' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='100' fill='currentColor' style='font-size:1em'>p&lt;/text>
&lt;text text-anchor='middle' x='56' y='148' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='164' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='196' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='56' y='228' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='276' fill='currentColor' style='font-size:1em'>p&lt;/text>
&lt;text text-anchor='middle' x='56' y='324' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='56' y='372' fill='currentColor' style='font-size:1em'>R&lt;/text>
&lt;text text-anchor='middle' x='64' y='20' fill='currentColor' style='font-size:1em'>C&lt;/text>
&lt;text text-anchor='middle' x='64' y='196' fill='currentColor' style='font-size:1em'>w&lt;/text>
&lt;text text-anchor='middle' x='64' y='372' fill='currentColor' style='font-size:1em'>E&lt;/text>
&lt;text text-anchor='middle' x='72' y='20' fill='currentColor' style='font-size:1em'>K&lt;/text>
&lt;text text-anchor='middle' x='72' y='100' fill='currentColor' style='font-size:1em'>=&lt;/text>
&lt;text text-anchor='middle' x='72' y='196' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='72' y='276' fill='currentColor' style='font-size:1em'>=&lt;/text>
&lt;text text-anchor='middle' x='72' y='372' fill='currentColor' style='font-size:1em'>T&lt;/text>
&lt;text text-anchor='middle' x='80' y='196' fill='currentColor' style='font-size:1em'>p&lt;/text>
&lt;text text-anchor='middle' x='80' y='324' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='88' y='100' fill='currentColor' style='font-size:1em'>1&lt;/text>
&lt;text text-anchor='middle' x='88' y='276' fill='currentColor' style='font-size:1em'>0&lt;/text>
&lt;text text-anchor='middle' x='88' y='324' fill='currentColor' style='font-size:1em'>r&lt;/text>
&lt;text text-anchor='middle' x='96' y='196' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='96' y='324' fill='currentColor' style='font-size:1em'>u&lt;/text>
&lt;text text-anchor='middle' x='104' y='196' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='104' y='324' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='112' y='196' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='120' y='196' fill='currentColor' style='font-size:1em'>p&lt;/text>
&lt;text text-anchor='middle' x='128' y='196' fill='currentColor' style='font-size:1em'>,&lt;/text>
&lt;text text-anchor='middle' x='128' y='260' fill='currentColor' style='font-size:1em'>f&lt;/text>
&lt;text text-anchor='middle' x='136' y='260' fill='currentColor' style='font-size:1em'>a&lt;/text>
&lt;text text-anchor='middle' x='144' y='196' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='144' y='260' fill='currentColor' style='font-size:1em'>l&lt;/text>
&lt;text text-anchor='middle' x='152' y='196' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='152' y='260' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='160' y='196' fill='currentColor' style='font-size:1em'>m&lt;/text>
&lt;text text-anchor='middle' x='160' y='260' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='168' y='196' fill='currentColor' style='font-size:1em'>p&lt;/text>
&lt;text text-anchor='middle' x='176' y='196' fill='currentColor' style='font-size:1em'>,&lt;/text>
&lt;text text-anchor='middle' x='192' y='196' fill='currentColor' style='font-size:1em'>s&lt;/text>
&lt;text text-anchor='middle' x='200' y='196' fill='currentColor' style='font-size:1em'>e&lt;/text>
&lt;text text-anchor='middle' x='208' y='196' fill='currentColor' style='font-size:1em'>c&lt;/text>
&lt;text text-anchor='middle' x='216' y='196' fill='currentColor' style='font-size:1em'>t&lt;/text>
&lt;text text-anchor='middle' x='224' y='196' fill='currentColor' style='font-size:1em'>i&lt;/text>
&lt;text text-anchor='middle' x='232' y='196' fill='currentColor' style='font-size:1em'>o&lt;/text>
&lt;text text-anchor='middle' x='240' y='196' fill='currentColor' style='font-size:1em'>n&lt;/text>
&lt;text text-anchor='middle' x='304' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='312' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='320' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='328' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='336' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;text text-anchor='middle' x='344' y='180' fill='currentColor' style='font-size:1em'> &lt;/text>
&lt;/g>
&lt;/svg>
&lt;/div>
&lt;p>which when implemented gives us the following assembly code&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">lock: #a0 - int* section
addi t0, zero, 1 #load 1 into t0
amoswap.w.aq t0, t0, (a0) #swap t0 =&amp;gt; (section) =&amp;gt; t0
bnez t0, lock #if t0 is not 0, try again
ret
unlock
amoswap.w.rl zero, zero, (a0)
ret
&lt;/code>&lt;/pre>&lt;p>The &lt;code>.w&lt;/code> in the instruction signifies that the swap is performed on a 32bit value (a Word).
There is also &lt;code>.d&lt;/code> that means that the swap is being performed on a 64b value (a Double word)&lt;/p>
&lt;p>The second thing we can se is the &lt;code>aq&lt;/code> and &lt;code>rl&lt;/code> flags. The &lt;code>aq&lt;/code> stands for &amp;ldquo;acquire constraint&amp;rdquo; and &lt;code>rq&lt;/code> stands for &amp;ldquo;release constraint&amp;rdquo;&lt;/p>
&lt;h2 id="memory-ordering-constraints">Memory ordering constraints&lt;/h2>
&lt;p>To understand what is being acomplished with the acquire and release constraints, we need to talk about the RISC-V memory model. RISC-V ISA specifies a relaxed memory model. This allows CPU architects to implement processors that execute instructions that access memory out of order. This increases performance, but leads to problems when making software.&lt;/p>
&lt;p>Let&amp;rsquo;s now assume that memory accesses can be reordered. Consider now these two lines of code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&amp;lt;- Other thread: head = head-&amp;gt;next;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//&amp;lt;- Other thread: unlock(&amp;amp;section);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> block &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>) head;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>lock&lt;/code> function executes the &lt;code>amoswap&lt;/code> we need to get exclusive access, and then we load value of &lt;code>head&lt;/code> into block. This seems correct, however when we take into consideration the fact that the CPU can execute instructions out of order, a possibility arises that the CPU will reorder the code to look something like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> block &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>) head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&amp;lt;- Other thread: head = head-&amp;gt;next;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//&amp;lt;- Other thread: unlock(&amp;amp;section);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is now incorrect since the CPU loaded the &lt;code>head&lt;/code> of the list before locking the section, and possibly read a wrong value. This sort of reordering renders our lock function useless. To fix this problem the standard defines acquire and release constraints for all atomic instructions. If we attach an acquire constraint using &lt;code>.aq&lt;/code>, the CPU must not reorder any memory operations after the &lt;code>amoswap.w.aq&lt;/code> to execute before it, preventing the situation above.&lt;/p>
&lt;p>A simillar situation can arise if we consider:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>head &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&amp;lt;-- Other thread: lock(&amp;amp;section);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//&amp;lt;-- Other thread: void* block = (void*) head;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>getting reordered by the CPU to execute like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&amp;lt;-- Other thread: lock(&amp;amp;section);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//&amp;lt;-- Other thread: void* block = (void*) head;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>head &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Which could cause another thread to read the wrong value by storing the new &lt;code>head&lt;/code> too late. This problem is fixed by attaching a release constraint using &lt;code>.rl&lt;/code>, which prevents the CPU from reordering any memory operations before &lt;code>amoswap.w.rl&lt;/code> to execute after it. This prevents the store getting reordered past &lt;code>unlock&lt;/code>.&lt;/p>
&lt;h2 id="beware-of-interrupts">Beware of interrupts&lt;/h2>
&lt;p>Let&amp;rsquo;s now consider that we might need to allocate memory inside of the interrupt routine. Let&amp;rsquo;s say the interrupt handler looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">interrupt&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">alloc_block&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We just introduced a bug, because the following can happen:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>TIME&lt;/th>
&lt;th>THREAD 1 (ON CORE 1)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1.&lt;/td>
&lt;td>alloc_block()&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2.&lt;/td>
&lt;td>-&amp;gt; lock(&amp;amp;section); // locks the section&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3.&lt;/td>
&lt;td>-&amp;gt; void* block = (void*) head;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4.&lt;/td>
&lt;td>-&amp;gt; //INTERRUPT TAKEN&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5.&lt;/td>
&lt;td>-&amp;gt; interrupt();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6.&lt;/td>
&lt;td>-&amp;gt; -&amp;gt; //&amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7.&lt;/td>
&lt;td>-&amp;gt; -&amp;gt; alloc_block();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8.&lt;/td>
&lt;td>-&amp;gt; -&amp;gt; -&amp;gt; lock(&amp;amp;section); // &amp;lt;- infinite wait&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The second call for lock will wait indefinetely, beacuse in the interrupt handler we are waiting for the lock to be unlocked, but it can&amp;rsquo;t get unlocked before the interrupt handler is finished. This situation is called a &lt;em>livelock&lt;/em>, because CPU will be executing what is effectively a while loop, forever.&lt;/p>
&lt;p>Now let&amp;rsquo;s fix this code. The obvious solution is to disable interrupts inside of the &lt;code>lock&lt;/code> function and enable them inside of the &lt;code>unlock&lt;/code> function. We will here assume that the kernel is running inside of Supervisor mode, and use the &lt;code>SIE&lt;/code> (Supervisor Interrupt Enable) bit of the &lt;code>sstatus&lt;/code> register to enable/disable interrupts.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-riscvasm" data-lang="riscvasm">lock: #a0 - int* section
csrci sstatus, 2 #clear SIE - disable interrupts
lock_loop:
addi t0, zero, 1 #load 1 into t0
amoswap.w.aq t0, t0, (a0) #swap t0 =&amp;gt; (section) =&amp;gt; t0
bnez t0, lock_loop #if t0 is not 0, try again
ret
unlock
amoswap.w.rl zero, zero, (a0)
csrsi sstatus, 2 #set SIE - enable interrupts
ret
&lt;/code>&lt;/pre>&lt;p>The logic behind this solution is that we can delay taking the interrupt if we are inside a locked section, leaving the interrupt to be taken after we unlock the section, fixing the issue.&lt;/p>
&lt;p>This solution, however, can still cause problems.
The problem with this solution happens when we have nested critical sections. The problem is that after the &lt;code>unlock&lt;/code> in the nested section, the interrupts will be turned ON which leads to the livelock demonstrated above.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">lock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>second_section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Interrupt are OFF here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> block &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">alloc_block&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Interrupts are ON here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">unlock&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>second_section)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will implement a fix for this solution, by counting how many times &lt;code>lock&lt;/code> was called, and remembering if interrupts were ON when &lt;code>lock&lt;/code> was initially called, and decreasing that number for every &lt;code>unlock&lt;/code>. Once that counter decreases to 0, we will enable interrupts if they were initially ON. For the sake of simplicity, we will be writing this version in C.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> depth
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> interrupts;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">core_t&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">core_t&lt;/span> cores[CORE_COUNT];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> section)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> interrupts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">intr_get&lt;/span>(); &lt;span style="color:#75715e">// check if interrupts are on
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">intr_off&lt;/span>(); &lt;span style="color:#75715e">// turn off interrutps
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">core_id&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">core_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span> core &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>cores[id];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// save previous interrupt state for cpu on first lock
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(core&lt;span style="color:#f92672">-&amp;gt;&lt;/span>depth&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core&lt;span style="color:#f92672">-&amp;gt;&lt;/span>interrupts &lt;span style="color:#f92672">=&lt;/span> interrupts;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amoswap_acquire&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val, section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">unlock&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> section)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">core_id&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">core_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span> core &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>cores[id];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amoswap_release&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val, section);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">--&lt;/span>core&lt;span style="color:#f92672">-&amp;gt;&lt;/span>depth &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> core&lt;span style="color:#f92672">-&amp;gt;&lt;/span>interrupts)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">intr_on&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The depth, and the interrupt state value is saved per CPU core, since all cores can be at different points of execution.&lt;/p>
&lt;h2 id="further-reading">Further reading&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.regehr.org/archives/2173">A closer look at a spinlock (x86, ARM)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://en.cppreference.com/w/cpp/atomic">Atomic builtins in C++&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://five-embeddev.com/riscv-isa-manual/latest/a.html#sec:amo">Atomic memory operations in RISC-V&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://five-embeddev.com/riscv-isa-manual/latest/a.html#specifying-ordering-of-atomic-instructions">Ordering constraints for atomic instructions in RISC-V&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c">xv6 spinlock implementation&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Showcase</title><link>https://strajabot.com/showcase/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://strajabot.com/showcase/</guid><description>nessy During the 4th semester, me and a couple of my friends designed and implemented a computer system on a FPGA board for extra credit in our Computer Architecture course. Our project, named nessy, is a computer system inspired by the NES console. It includes:
A CPU compatible with the MOS 6502 instruction set A GPU that can draw a pixel, line and rectangle. It uses the board&amp;rsquo;s SDRAM to store the framebuffer.</description><content>&lt;h2 id="nessy">nessy&lt;/h2>
&lt;p>During the 4th semester, me and a couple of my friends designed and implemented a computer system on a FPGA board for extra credit in our Computer Architecture course. Our project, named nessy, is a computer system inspired by the NES console. It includes:&lt;/p>
&lt;ul>
&lt;li>A CPU compatible with the MOS 6502 instruction set&lt;/li>
&lt;li>A GPU that can draw a pixel, line and rectangle. It uses the board&amp;rsquo;s SDRAM to store the framebuffer. The GPU outputs an 800x600 video to the screen over VGA.&lt;/li>
&lt;li>Two keyboard controllers that can be used to emulate up to 4 NES gamepads.&lt;/li>
&lt;/ul>
&lt;p>Link: &lt;a href="https://github.com/BogdanW3/nessy">https://github.com/BogdanW3/nessy&lt;/a>&lt;/p>
&lt;h2 id="nessy-cpu-sim">nessy-cpu-sim&lt;/h2>
&lt;p>While we were working on nessy, we needed a way to simulate running code on the CPU to test for compatibilty. To do this we implemented a way run the CPU in Verilator, and wrote a C++ wrapper that simulates the memory and memory mapped registers. The tests can be written in C, C++ and assembly, and are compiled using llvm-mos using our custom platform support. After the code runs, registers and memory are checked against expected values, to check if the instruction is correctly implemented.&lt;/p>
&lt;p>Link: &lt;a href="https://github.com/strajabot/nessy-cpu-sim">https://github.com/strajabot/nessy-cpu-sim&lt;/a>&lt;/p>
&lt;h2 id="llvm-mos-nessy">llvm-mos-nessy&lt;/h2>
&lt;p>Since optimzed assembly for the MOS 6502 instruction set is really difficult to write by hand, we wanted to use an existing compiler to write our tests and the game. We settled on using llvm-mos since it seemed the easiest to work with. However since we didn&amp;rsquo;t implement the NES PPU and APU, we coudn&amp;rsquo;t use the preexisting platform support, which led me to port the code to our platform. This includes changes to the linker script and common runtime.&lt;/p>
&lt;p>Link: &lt;a href="https://github.com/strajabot/llvm-mos-nessy">https://github.com/strajabot/llvm-mos-nessy&lt;/a>&lt;/p></content></item><item><title>About</title><link>https://strajabot.com/about/</link><pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate><guid>https://strajabot.com/about/</guid><description>Hello there My name is Strahinja.
I&amp;rsquo;m a third year Computer Engineering student at the School of Electrical Engineering, University of Belgrade.
I started programming at the age of 14 when I developed my first Minecraft plugin, which became my passion that I kept pursuing all the way through high school. This passion for programming Minecraft plugins helped me become proficient in the Java programming language. At that time I got interested in backend web development, which led me to learn about NodeJS, databases and Typescript.</description><content>&lt;h2 id="hello-there">Hello there&lt;/h2>
&lt;p>My name is Strahinja.&lt;/p>
&lt;p>I&amp;rsquo;m a third year Computer Engineering student at the School of Electrical Engineering, University of Belgrade.&lt;/p>
&lt;p>I started programming at the age of 14 when I developed my first Minecraft plugin, which became my passion that I kept pursuing all the way through high school. This passion for programming Minecraft plugins helped me become proficient in the Java programming language. At that time I got interested in backend web development, which led me to learn about NodeJS, databases and Typescript.&lt;/p>
&lt;p>After I had been sharpening my Minecraft plugin programming skills for 3-4 years, I started working as a freelance Minecraft plugin developer, and worked through the latter years of high school. I wrote code that was responsible for interfacing with PostgreSQL for storing player data, and RabbitMQ for passing messages between server and proxy instances. I also learned how to use Git and build systems like Gradle.&lt;/p>
&lt;p>In the year 2021, I enrolled at the University of Belgrade. During my first and second year of university I found my passion for low-level programming and hardware. I am currently working very hard on learning about operating systems, computer architecture and oragnization, as well as digital design.&lt;/p></content></item></channel></rss>